use crate::dac::pattern_type::PatternType;
use easy_ext::ext;
use std::{
    cell::LazyCell,
    collections::{BTreeMap, HashSet},
};

/*
grep -E "^(\|\||\.)" blocklist.txt | sed -E 's#^(\|\||\.)([^.]+).*#\2#' | sort | uniq -c | sort -rn | head -n 100
*/

pub static mut INNER_SUBDOMAIN_BLACKLIST: LazyCell<HashSet<String>> = LazyCell::new(|| {
    HashSet::from_iter(
        [
            "6519114",
            "a8",
            "a8aspconv",
            "a8clk",
            "a8cv",
            "a8net",
            "a8trck",
            "aa-metrics",
            "aa",
            "ablink",
            "ablinks",
            "ac-ebis",
            "acton",
            "acv",
            "ad",
            "adbmetrics",
            "adbsmetr",
            "adbsmetrics",
            "adebis",
            "adobeanalytics",
            "adobemetrics",
            "ads",
            "adtarget",
            "adtd",
            "adv",
            "advert",
            "aff",
            "affiliate",
            "ainu",
            "analytic",
            "analytics",
            "analyticsresults",
            "axp",
            "beacon",
            "bnc",
            "bxumze",
            "click",
            "clicks",
            "clk",
            "clks",
            "clnbze",
            "cmp",
            "cname",
            "cnt",
            "collect",
            "collector",
            "cookies",
            "count",
            "counter",
            "cqpmvc",
            "cueohf",
            "data-ssl",
            "dc",
            "dcclaa",
            "dcs",
            "dii1",
            "dii2",
            "dii3",
            "dii4",
            "dynamicyield",
            "ebis-tracking",
            "ebis",
            "ebiscname",
            "eloqua",
            "elq",
            "elqtracking",
            "elqtrk",
            "email-am",
            "email-ap",
            "email-cm",
            "email-em",
            "endljp",
            "engage",
            "eulerian",
            "event",
            "events",
            "fahmta",
            "fbu8",
            "fp",
            "fpc",
            "fpida",
            "frdoki",
            "fudezz",
            "geoip",
            "gostats",
            "hcjpbc",
            "hits",
            "hiuplq",
            "hs-analytics",
            "hsa",
            "ijaabm",
            "insight",
            "insights",
            "iqmetrics",
            "jdgtgb",
            "links",
            "logger",
            "lpbhnv",
            "lxsway",
            "mds",
            "mdws",
            "metric",
            "metrics",
            "mkt",
            "mktg",
            "nsc",
            "nsmetrics",
            "ogb2",
            "oimg",
            "om",
            "omn",
            "omni",
            "omniture-ssl",
            "omniture",
            "oms",
            "omtrdc",
            "osimg",
            "outreach",
            "pardot",
            "partner",
            "pdmsmrt",
            "ping",
            "pix",
            "pixel",
            "plau",
            "plausible",
            "popin",
            "prd",
            "prism",
            "profiling",
            "purpose",
            "pv",
            "px",
            "refer",
            "referral",
            "repdata",
            "response",
            "rum",
            "saa",
            "sadbmetrics",
            "sadobe",
            "sadobemarketing",
            "sanalytics",
            "sanl",
            "sc",
            "scookies-adobe",
            "sdata",
            "sdc",
            "secmetrics",
            "secureanalytics",
            "securecookies",
            "securecookiesdustininfo",
            "securedata",
            "securemetrics",
            "securetags",
            "seyfwl",
            "simg",
            "smetric",
            "smetrics",
            "snalytics",
            "som",
            "somni",
            "somniture",
            "somtrdc",
            "sonar6",
            "spersonalization",
            "srepdata",
            "ssa",
            "ssc",
            "sslanalytics",
            "sslstats",
            "sst",
            "sstat",
            "sstats",
            "starget",
            "stat-ssl",
            "stat",
            "statistics",
            "stats",
            "stats2",
            "stmetrics",
            "strack",
            "sw88",
            "swa",
            "swasc",
            "swebanalytics",
            "sxjfhh",
            "t-s",
            "tag",
            "tags",
            "target",
            "tdf1",
            "telemetry",
            "tk",
            "tms",
            "tp",
            "tr",
            "tr1",
            "track",
            "tracker",
            "tracking",
            "tracking1",
            "tracking2",
            "trackingssl",
            "traffic",
            "trck",
            "trk",
            "utiq",
            "veqvek",
            "views",
            "visit",
            "visualwebsiteoptimizer",
            "w88",
            "waaf1",
            "wbtrkk",
            "webanalytics",
            "webstat",
            "webstats",
            "webtarget",
            "webtracking",
            "wt",
            "wttd",
            "ydtzzw",
            "ywrcqa",
            "marketing",
            "newsletter",
            "campaign",
            "campaigns",
            "promo",
            "promotions",
            "everyonesocial",
            "mailing",
            "consent",
            "cookie",
            "offers",
            "adat",
            "banners",
            "promos",
            "asg",
            "partners",
        ]
        .into_iter()
        .map(String::from),
    )
});

#[ext(PatternsMap)]
pub impl BTreeMap<String, u32> {
    fn add_pattern(&mut self, ptype: PatternType, mut value: String) {
        let base_idx = 10 + (self.len() as u32);
        // Сдвигаем на 29 бит влево.
        // В u32 останется: [B B B I I I I I I I I I I I I I I I I I I I I I I I I I I I]
        // Где B - биты типа, I - биты индекса.
        value.make_ascii_lowercase();
        self.entry(value).or_insert(ptype.0 | base_idx);
    }

    fn add_shared_subdomain_pattern(&mut self, subdomain: &str) -> bool {
        let mut exist = false;
        for sd in subdomain.to_ascii_lowercase().split('.') {
            unsafe {
                #[allow(static_mut_refs)]
                if INNER_SUBDOMAIN_BLACKLIST.contains(sd) {
                    self.add_pattern(PatternType::AnyDomainPartBeforeETLD, format!("{sd}."));
                    exist = true;
                }
            }
        }
        exist
    }
}
